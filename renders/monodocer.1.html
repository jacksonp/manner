<!DOCTYPE html>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="man-page-info" data-date="" data-package="" data-section-name="">
<title>monodocer</title>
<h1>monodocer</h1>
<div class="section">
  <h2>NAME</h2>
  <p>monodocer - ECMA Documentation Format Support
</div>
<div class="section">
  <h2>SYNOPSIS</h2>
  <p><strong>monodocer</strong> [OPTIONS]*
</div>
<div class="section">
  <h2>OPTIONS</h2>
  <dl>
    <dt><em>-assembly:ASSEMBLY</em>
    <dd><em>ASSEMBLY</em> is a .NET assembly to generate documentation stubs for.<br>
    <br>
    Specify a file path or the name of a GAC'd assembly.
    <dt><em>-delete</em>
    <dd>Allow monodocer to delete members from documentation files. The only members deleted are for members which are no longer present within the assembly.<br>
    <br>
    If a type is no longer present, the documentation file is <em>not</em> deleted, but is instead <em>renamed</em> to have a <strong>.remove</strong> extension.
    <dt><em>-?, -help</em>
    <dd>Show program argument information.
    <dt><em>-ignoremembers</em>
    <dd>Do not update members.<br>
    <br>
    This will add documentation stubs for added types, but will <em>not</em> add or remove documentation for any members of any type (including any added types).
    <dt><em>-importslashdoc:FILE</em>
    <dd><em>FILE</em> is an XML file generated with the <strong>/doc:FILE</strong> C# compiler flag (e.g. <em>mcs -doc:foo.xml foo.cs</em> ). Import the member documentation contained within <em>FILE</em> into the documentation format used by monodoc.
    <dt><em>-name:NAME</em>
    <dd><em>NAME</em> is the name of the project this documentation is for.<br>
    <br>
    This sets the <em>/Overview/Title</em> element within the <em>index.xml</em> file created at the directory specified by <em>-path</em> . This is used by some programs for title information (e.g. <em>monodocs2html</em> ).
    <dt><em>-namespace:NAMESPACE</em>
    <dd>Only update the types within the namespace <em>NAMESPACE</em> .
    <dt><em>-overrides</em>
    <dd>Include overridden methods in documentation.<br>
    <br>
    This normally isn't necessary, as the Mono Documentation Browser will provide a link to the base type members anyway, as will <em>monodocs2html</em> if the base type is within the same assembly.
    <dt><em>-path:OUTPUT_DIR</em>
    <dd><em>OUTPUT_DIR</em> is the directory which will contain the new/updated documentation stubs.
    <dt><em>-pretty</em>
    <dd>Indent the XML files nicely.
    <dt><em>-since:SINCE</em>
    <dd>
      <p>Create a &lt;since/&gt; element for added types and members with the value <em>SINCE</em> .<br>
      <br>
      For example, when given <em>-since:"Gtk# 2.4"</em> an element will be inserted into the <em>Docs</em> element for all added types and type members:
      <pre>      &lt;since version="Gtk# 2.4" /&gt;</pre>
      <p>The Mono Documentation Browser and <em>monodocs2html</em> will use this element to specify in which version a member was added.
    <dt><em>-type:TYPE</em>
    <dd>Only create/update documentation for the type <em>TYPE</em> .
    <dt><em>-updateto:PATH</em>
    <dd>When updating documentation, write the updated documentation files into the directory <em>PATH</em> .
    <dt><em>-V, -version</em>
    <dd>Display version and licensing information.
  </dl>
</div>
<div class="section">
  <h2>DESCRIPTION</h2>
  <p><strong>monodocer</strong> has been obsoleted by <strong>mdoc</strong>(1). See the <strong>mdoc-update</strong>(1) man page.
  <p><em>monodocer</em> is a program that creates XML documentation stubs in the ECMA Documentation Format. It does not rely on documentation found within the source code.
  <p>The advantages are:
  <dl>
    <dt><em>*</em>
    <dd><strong>Code readability.</strong> Good documentation is frequently (a) verbose, and (b) filled with examples. (For comparison, compare Microsoft .NET Framework documentation, which is often a page or more of docs for each member, to JavaDoc documentation, which can often be a sentence for each member.)<br>
    <br>
    Inserting good documentation into the source code can frequently bloat the source file, as the documentation can be longer than the actual method that is being documented.
    <dt><em>*</em>
    <dd><strong>Localization.</strong> In-source documentation formats (such as <strong>/doc</strong> ) have no support for multiple human languages. If you need to support more than one human language for documentation purposes, <em>monodocer</em> is useful as it permits each language to get its own directory, and <em>monodocer</em> can add types/members for each separate documentation directory.
    <dt><em>*</em>
    <dd><strong>Administration.</strong> It's not unusual to have separate documentation and development teams. It's also possible that the documentation team will have minimal experience with the programming language being used. In such circumstances, inline documentation is not desirable as the documentation team could inadvertantly insert an error into the source code while updating the documentation. Alternatively, you may not want the documentation team to have access to the source code for security reasons. <em>monodocer</em> allows the documentation to be kept <em>completely</em> separate and distinct from the source code used to create the assembly.
  </dl>
  <p>To turn the <em>monodocer</em> documentation into something that can be consumed by the Mono Documentation Browser (the desktop help browser, or the web interface for it) it is necessary to compile the documentation into a packed format. This is done with the mdassembler tool, for example, you could use this toolchain like this:
  <pre>        $ monodocer -assembly:MyWidgets -path:generated_docs
        $ mdassembler --ecma generated_docs -out:MyWidgets</pre>
  <p>The above would generate a MyWidgets.zip and a MyWidgets.tree that can then be installed in the system. In addition to the two files (.zip and .tree) you must provide a .sources file which describes where in the help system the documentation should be hooked up, it is a very simple XML file, like this:
  <pre>&lt;?xml version="1.0"?&gt;
&lt;monodoc&gt;
  &lt;source provider="ecma" basefile="MyWidgets" path="classlib-gnome"/&gt;
&lt;/monodoc&gt;</pre>
  <p>The above configuration file describes that the documentation is in ECMA format (the compiled version) that the base file name is MyWidgets and that it should be hooked up in the "classlib-gnome" part of the tree. If you want to look at the various nodes defined in the documentation, you can look at monodoc.xml file which is typically installed in /usr/lib/monodoc/monodoc.xml.
  <p>Once you have all of your files (.zip, .tree and .sources) you can install them into the system with the following command:
  <pre>        $ cp MyWidgets.tree MyWidgets.zip MyWidgets.source `pkg-config monodoc --variable sourcesdir`</pre>
  <p>The above will copy the files into the directory that Monodoc has registered (you might need root permissions to do this). The actual directory is returned by the <em>pkg-config</em> invocation.
</div>
<div class="section">
  <h2>STRING ID FORMAT</h2>
  <p>String IDs are used to refer to a type or member of a type. String IDs are documented in ECMA-334 3rd Edition, Annex E.3.1. They consist of a <em>member type prefix</em> , the full type name (namespace + name, separated by '.'), possibly followed by the member name and other information.
  <p>Member type prefixes:
  <dl>
    <dt><em>E:</em>
    <dd>The String ID refers to an event. The event name follows the type name: <em>E:System.AppDomain.AssemblyLoad</em>
    <dt><em>F:</em>
    <dd>The String ID refers to a field. The field name follows the type name: <em>F:System.Runtime.InteropServices.DllImportAttribute.SetLastError</em>
    <dt><em>M:</em>
    <dd>Refers to a constructor or method. Constructors append <em>.ctor</em> to the type name, while methods append the method name (with an optional count of the number of generic parameters).<br>
    <br>
    If the constructor or method take arguments, these are listed within paranthesis after the constructor/method name:<br>
    <br>
    <em>M:System.Object..ctor</em> , <em>M:System.String..ctor(System.Char[])</em> , <em>M:System.String.Concat(System.Object)</em> , <em>M:System.Array.Sort``1(``0[])</em> , <em>M:System.Collections.Generic.List`1..ctor</em> , <em>M:System.Collections.Generic.List`1.Add(`0)</em> .
    <dt><em>N:</em>
    <dd>Refers to a namespace, e.g. <em>N:System</em>
    <dt><em>P:</em>
    <dd>Refers to a property. If the property is an indexer or takes parameters, the parameter types are appended to the property name and enclosed with paranthesis: <em>P:System.String.Length</em> , <em>P:System.String.Chars(System.Int32)</em> .
    <dt><em>T:</em>
    <dd>The String ID refers to a type, with the number of generic types appended: <em>T:System.String</em> , <em>T:System.Collections.Generic.List`1</em>
  </dl>
  <p>To make matters more interesting, generic types & members have two representations: the "unbound" representation (shown in examples above), in which class names have the count of generic parameters appended to their name. There is also a "bound" representation, in which the binding of generic parameters is listed within '{' and '}'.
  <p><strong>Unbound:</strong> <em>T:System.Collections.Generic.List`1</em> , <em>T:System.Collections.Generic.Dictionary`2</em> .
  <p><strong>Bound:</strong> <em>T:System.Collections.Generic.List{System.Int32}</em> <em>T:System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{System.Predicate{System.String}}}</em> .
  <p>As you can see, bound variants can be arbitrarily complex (just like generics).
  <p>Furthermore, if a generic parameter is bound to the generic parameter of a type or method, the "index" of the type/method's generic parameter is used as the binding, so given
  <pre>    class FooType {
          public static void Foo&lt;T&gt; (System.Predicate&lt;T&gt; predicate) {}
        }</pre>
  <p>The String ID for this method is <em>M:FooType.Foo``1(System.Predicate{``0})</em> , as <em>``0</em> is the 0th generic parameter index which is bound to <em>System.Predicate&lt;T&gt;</em> .
</div>
<div class="section">
  <h2>DOCUMENTATION FORMAT</h2>
  <p><em>monodocer</em> generates documentation similar to the Ecma documentation format, as described in ECMA-335 3rd Edition, Partition IV, Chapter 7.
  <p>The principal difference from the ECMA format is that each type gets its own file, within a directory identical to the namespace of the type.
  <p>Most of the information within the documentation should <em>not</em> be edited. This includes the type name ( <em>/Type/@FullName</em> ), implemented interfaces ( <em>/Type/Interfaces</em> ), member information ( <em>/Type/Members/Member/@MemberName</em> , <em>/Type/Members/Member/MemberSignature</em> , <em>/Type/Members/Member/MemberType</em> , <em>/Type/Members/Member/Parameters</em> , etc.).
  <p>What <em>should</em> be modified are all elements with the text <em>To be added.</em> , which are present under the <em>//Docs</em> elements (e.g. <em>/Type/Docs</em> , <em>/Type/Members/Member/Docs</em> ). The contents of the <em>Docs</em> element is <em>identical</em> in semantics and structure to the inline C# documentation format, consisting of these elements (listed in ECMA-334 3rd Edition, Annex E, Section 2). The following are used within the element descriptions:
  <dl>
    <dt><em>CREF</em>
    <dd>Refers to a class (or member) reference, and is a string in the format described above in the <em>STRING ID FORMAT</em> section.
    <dt><em>TEXT</em>
    <dd>Non-XML text, and XML should not be nested.
    <dt><em>XML</em>
    <dd>Only XML elements should be nested (which indirectly may contain text), but non-whitespace text should not be an immediate child node.
    <dt><em>XML_TEXT</em>
    <dd>Free-form text and XML, so that other XML elements may be nested.
  </dl>
  <p>The following elements are used in documentation:
  <dl>
    <dt><em>&lt;block subset="SUBSET" type="TYPE"&gt;XML_TEXT&lt;/block&gt;</em>
    <dd>Create a block of text, similar in concept to a paragraph, but is used to create divisions within the text. To some extent, a &lt;block/&gt; is equivalent to the HTML &lt;h2/&gt; tag.<br>
    <br>
    <em>SUBSET</em> should always be the value <em>none</em> .<br>
    <br>
    <em>TYPE</em> specifies the heading and formatting to use. Recognized types are:<br>
    <br>
    <em>behaviors</em> Creates a section with the heading <em>Operation</em> .<br>
    <br>
    <em>note</em> Creates a section with the heading <em>Note:</em> .<br>
    <br>
    <em>overrides</em> Creates a section with the heading <em>Note to Inheritors</em> .<br>
    <br>
    <em>usage</em> Creates a section with the heading <em>Usage</em> .
    <dt><em>&lt;c&gt;XML_TEXT&lt;/c&gt;</em>
    <dd>Set text in a code-like font (similar to the HTML &lt;tt/&gt; element).
    <dt><em>&lt;code lang="LANGUAGE"&gt;TEXT&lt;/code&gt;</em>
    <dd>Display multiple lines of text in a code-like font (similar to the HTML &lt;pre/&gt; element). <em>LANGUAGE</em> is the language this code block is for. For example, if <em>LANGUAGE</em> is <strong>C#</strong> , then <em>TEXT</em> will get syntax highlighting for the C# language within the Mono Documentation Browser.
    <dt><em>&lt;example&gt;XML_TEXT&lt;/example&gt;</em>
    <dd>
      <p>Indicates an example that should be displayed specially. For example:
      <pre>        &lt;example&gt;
          &lt;para&gt;An introductory paragraph.&lt;/para&gt;
          &lt;code lang="C#"&gt;
            class Example {
              public static void Main ()
              {
                System.Console.WriteLine ("Hello, World!");
              }
            }
          &lt;/code&gt;
        &lt;/example&gt;</pre>
    <dt><em>&lt;exception cref="CREF"&gt;XML_TEXT&lt;/exception&gt;</em>
    <dd>
      <p>Identifies an exception that can be thrown by the documented member.<br>
      <br>
      <em>&lt;exception/&gt;</em> is a top-level element, and should be nested directly under the <em>&lt;Docs/&gt;</em> element.<br>
      <br>
      <em>CREF</em> is the exception type that is thrown, while <em>XML_TEXT</em> contains the circumstances that would cause <em>CREF</em> to be thrown.
      <pre>      &lt;exception cref="T:System.ArgumentNullException"&gt;
          &lt;paramref name="foo" /&gt; was &lt;see langword="null" /&gt;.
        &lt;/exception&gt;</pre>
    <dt><em>&lt;list&gt;XML&lt;/list&gt;</em>
    <dd>
      <p>Create a list or table of items. <em>&lt;list/&gt;</em> makes use of nested <em>&lt;item&gt;XML&lt;/item&gt;</em> , <em>&lt;listheader&gt;XML&lt;/listheader&gt;</em> , <em>&lt;term&gt;XML_TEXT&lt;/term&gt;</em> , and <em>&lt;description&gt;XML_TEXT&lt;/description&gt;</em> elements.<br>
      <br>
      <em>Lists</em> have the syntax:
      <pre>        &lt;list type="bullet"&gt; &lt;!-- or type="number" --&gt;
          &lt;item&gt;&lt;term&gt;Bullet 1&lt;/term&gt;&lt;/item&gt;
          &lt;item&gt;&lt;term&gt;Bullet 2&lt;/term&gt;&lt;/item&gt;
          &lt;item&gt;&lt;term&gt;Bullet 3&lt;/term&gt;&lt;/item&gt;
        &lt;/list&gt;</pre>
      <p><em>Tables</em> have the syntax:
      <pre> &lt;list type="table"&gt;
          &lt;listheader&gt; &lt;!-- listheader bolds this row --&gt;
            &lt;term&gt;Column 1&lt;/term&gt;
            &lt;description&gt;Column 2&lt;/description&gt;
            &lt;description&gt;Column 3&lt;/description&gt;
          &lt;/listheader&gt;
          &lt;item&gt;
            &lt;term&gt;Item 1-A&lt;/term&gt;
            &lt;description&gt;Item 1-B&lt;/description&gt;
            &lt;description&gt;Item 1-C&lt;/description&gt;
          &lt;/item&gt;
          &lt;item&gt;
            &lt;term&gt;Item 2-A&lt;/term&gt;
            &lt;description&gt;Item 2-B&lt;/description&gt;
            &lt;description&gt;Item 2-C&lt;/description&gt;
          &lt;/item&gt;
        &lt;/list&gt;</pre>
    <dt><em>&lt;para&gt;XML_TEXT&lt;/para&gt;</em>
    <dd>
      <p>Insert a paragraph of <em>XML_TEXT</em><br>
      . This is for use within other tags, such as <em>&lt;example/&gt;</em> , <em>&lt;remarks/&gt;</em> , <em>&lt;returns/&gt;</em> , <em>&lt;term/&gt;</em> and <em>&lt;description/&gt;</em> (see <em>&lt;list/&gt;</em> , above), and most other elements.<br>
      <br>
      For example,
      <pre>        &lt;para&gt;This is a paragraph of text.&lt;/para&gt;</pre>
    <dt><em>&lt;param name="NAME"&gt;XML_TEXT&lt;/param&gt;</em>
    <dd>
      <p><em>&lt;param/&gt;</em> is a top-level element, and should be nested directly under the <em>&lt;Docs/&gt;</em> element.<br>
      <br>
      Describes the parameter <em>NAME</em> of the current constructor, method, or property:
      <pre>        &lt;param name="count"&gt;
          A &lt;see cref="T:System.Int32" /&gt; containing the number
          of widgets to process.
        &lt;/param&gt;</pre>
    <dt><em>&lt;paramref name="NAME" /&gt;</em>
    <dd>Indicates that <em>NAME</em> is a parameter.<br>
    <br>
    This usually renders <em>NAME</em> as italic text, so it is frequently (ab)used as an equivalent to the HTML &lt;i/&gt; element. See the <em>&lt;exception/&gt;</em> documentation (above) for an example.
    <dt><em>&lt;permission cref="CREF"&gt;XML_TEXT&lt;/permission&gt;</em>
    <dd>
      <p>Documentes the security accessibility requirements of the current member.<br>
      <br>
      <em>&lt;permission/&gt;</em> is a top-level element, and should be nested directly under the <em>&lt;Docs/&gt;</em> element.<br>
      <br>
      <em>CREF</em> is a type reference to the security permission required, while <em>XML_TEXT</em> is a description of why the permission is required.
      <pre>       &lt;permission cref="T:System.Security.Permissions.FileIOPermission"&gt;
          Requires permission for reading and writing files. See
          &lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;,
          &lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;.
        &lt;/permission&gt;</pre>
    <dt><em>&lt;remarks&gt;XML_TEXT&lt;/remarks&gt;</em>
    <dd>
      <p>Contains detailed information about a member.<br>
      <br>
      <em>&lt;remarks/&gt;</em> is a top-level element, and should be nested directly under the <em>&lt;Docs/&gt;</em> element.
      <pre> &lt;remarks&gt;Insert detailed information here.&lt;/remarks&gt;</pre>
    <dt><em>&lt;returns&gt;XML_TEXT&lt;/returns&gt;</em>
    <dd>
      <p><em>&lt;remarks/&gt;</em> is a top-level element, and should be nested directly under the <em>&lt;Docs/&gt;</em> element.<br>
      <br>
      Describes the return value of a method:
      <pre>  &lt;returns&gt;
          A &lt;see cref="T:System.Boolean" /&gt; specifying whether
          or not the process can access
          &lt;see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /&gt;.
        &lt;/returns&gt;</pre>
    <dt><em>&lt;see cref="CREF" /&gt;</em>
    <dd>
      <p>Creates a link to the specified member within the current text:
      <pre>   &lt;see cref="M:Some.Namespace.With.Type.Method" /&gt;</pre>
    <dt><em>&lt;seealso cref="CREF" /&gt;</em>
    <dd>
      <p><em>&lt;seealso/&gt;</em> is a top-level element, and should be nested directly under the <em>&lt;Docs/&gt;</em> element.<br>
      <br>
      Allows an entry to be generated for the <em>See Also</em> subclause. Use <em>&lt;see/&gt;</em> to specify a link from within text.
      <pre>        &lt;seealso cref="P:System.Exception.Message" /&gt;</pre>
    <dt><em>&lt;since version="VERSION" /&gt;</em>
    <dd>
      <p><em>&lt;since/&gt;</em> is a top-level element, and should be nested directly under the <em>&lt;Docs/&gt;</em> element.<br>
      <br>
      Permits specification of which version introduced the specified type or member.
      <pre>       &lt;since version="Gtk# 2.4" /&gt;</pre>
    <dt><em>&lt;summary&gt;DESCRIPTION&lt;/summary&gt;</em>
    <dd><em>&lt;summary/&gt;</em> is a top-level element, and should be nested directly under the <em>&lt;Docs/&gt;</em> element.<br>
    <br>
    Provides a (brief!) overview about a type or type member.<br>
    <br>
    This is usually displayed as part of a class declaration, and should be a reasonably short description of the type/member. Use <em>&lt;remarks/&gt;</em> for more detailed information.
    <dt><em>&lt;typeparam name="NAME"&gt;DESCRPITION&lt;/typeparam&gt;</em>
    <dd>
      <p><em>&lt;typeparam/&gt;</em> is a top-level element, and should be nested directly under the <em>&lt;Docs/&gt;</em> element.<br>
      <br>
      This is used to describe type parameter for a generic type or generic method.<br>
      <br>
      <em>NAME</em> is the name of the type parameter, while <em>DESCRIPTION</em> contains a description of the parameter (what it's used for, what restrictions it must meet, etc.).
      <pre>   &lt;typeparam name="T"&gt;The type of the underlying collection&lt;/typeparam&gt;</pre>
    <dt><em>&lt;typeparamref&gt;</em>
    <dd>
      <p>Used to indicate that a word is a type parameter, for use within other text blocks (e.g. within <em>&lt;para/&gt;</em> ).
      <pre>    &lt;para&gt;If &lt;typeparamref name="T" /&gt; is a struct, then...&lt;/para&gt;</pre>
    <dt><em>&lt;value&gt;DESCRIPTION&lt;/value&gt;</em>
    <dd>
      <p><em>&lt;value/&gt;</em> is a top-level element, and should be nested directly under the <em>&lt;Docs/&gt;</em> element.<br>
      <br>
      Allows a property to be described.
      <pre>  &lt;value&gt;
          A &lt;see cref="T:System.String" /&gt; containing a widget name.
        &lt;/value&gt;</pre>
  </dl>
</div>
<div class="section">
  <h2>SEE ALSO</h2>
  <p>mdassembler(1), mdcs2ecma(1), mdnormalizer(1), mdvalidator(1), monodocs2html(1)
</div>
<div class="section">
  <h2>MAILING LISTS</h2>
  <p>Visit http://lists.ximian.com/mailman/listinfo/mono-docs-list for details.
</div>
<div class="section">
  <h2>WEB SITE</h2>
  <p>Visit http://www.mono-project.com for details
</div>

