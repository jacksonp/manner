<!DOCTYPE html>
<meta charset="utf-8">
<meta name="man-page-info" data-extra1="June 2014" data-extra2="util-linux" data-extra3="User Commands">
<title>SCRIPT</title>
<h1>SCRIPT</h1>
<section>
  <h2>NAME</h2>
  <p>script - make typescript of terminal session
</section>
<section>
  <h2>SYNOPSIS</h2>
  <p><strong>script</strong> [options] [<em>file</em>]
</section>
<section>
  <h2>DESCRIPTION</h2>
  <p><strong>script</strong> makes a typescript of everything displayed on your terminal. &nbsp;It is useful for students who need a hardcopy record of an interactive session as proof of an assignment, as the typescript file can be printed out later with <strong>lpr</strong>(1).
  <p>If the argument <em>file</em> is given, <strong>script</strong> saves the dialogue in this <em>file</em>. If no filename is given, the dialogue is saved in the file <strong>typescript</strong>.
</section>
<section>
  <h2>OPTIONS</h2>
  <dl>
    <dt><strong>-a</strong>, <strong>--append</strong>
    <dd>
      <p>Append the output to <em>file</em> or to <strong>typescript</strong>, retaining the prior contents.
    <dt><strong>-c</strong>, <strong>--command</strong> <em>command</em>
    <dd>
      <p>Run the <em>command</em> rather than an interactive shell. &nbsp;This makes it easy for a script to capture the output of a program that behaves differently when its stdout is not a tty.
    <dt><strong>-e</strong>, <strong>--return</strong>
    <dd>
      <p>Return the exit code of the child process. &nbsp;Uses the same format as bash termination on signal termination exit code is 128+n.
    <dt><strong>-f</strong>, <strong>--flush</strong>
    <dd>
      <p>Flush output after each write. &nbsp;This is nice for telecooperation: one person does `mkfifo foo; script -f foo', and another can supervise real-time what is being done using `cat foo'.
    <dt><strong>--force</strong>
    <dd>
      <p>Allow the default output destination, i.e. the typescript file, to be a hard or symbolic link. &nbsp;The command will follow a symbolic link.
    <dt><strong>-q</strong>, <strong>--quiet</strong>
    <dd>
      <p>Be quiet (do not write start and done messages to either standard output or the typescript file).
    <dt><strong>-t</strong>, <strong>--timing</strong>[=<em>file</em>]
    <dd>
      <p>Output timing data to standard error, or to <em>file</em> when given. &nbsp;This data contains two fields, separated by a space. &nbsp;The first field indicates how much time elapsed since the previous output. &nbsp;The second field indicates how many characters were output this time. &nbsp;This information can be used to replay typescripts with realistic typing and output delays.
    <dt><strong>-V</strong>, <strong>--version</strong>
    <dd>
      <p>Display version information and exit.
    <dt><strong>-h</strong>, <strong>--help</strong>
    <dd>
      <p>Display help text and exit.
  </dl>
</section>
<section>
  <h2>NOTES</h2>
  <p>The script ends when the forked shell exits (a <em>control-D</em> for the Bourne shell (<strong>sh</strong>(1)), and <em>exit</em>, <em>logout</em> or <em>control-d</em> (if <em>ignoreeof</em> is not set) for the C-shell, <strong>csh</strong>(1)).
  <p>Certain interactive commands, such as <strong>vi</strong>(1), create garbage in the typescript file. <strong>script</strong> works best with commands that do not manipulate the screen, the results are meant to emulate a hardcopy terminal.
  <p>It is not recommended to run <strong>script</strong> in non-interactive shells. &nbsp;The inner shell of <strong>script</strong> is always interactive, and this could lead to unexpected results. &nbsp;If you use <strong>script</strong> in the shell initialization file, you have to avoid entering an infinite loop. &nbsp;You can use for example the <strong>.profile</strong> file, which is read by login shells only:
  <pre class="indent-7">if test -t 0 ; then
    script
    exit
fi</pre>
  <p>You should also avoid use of script in command pipes, as <strong>script</strong> can read more input than you would expect.
</section>
<section>
  <h2>ENVIRONMENT</h2>
  <p>The following environment variable is utilized by <strong>script</strong>:
  <dl>
    <dt><strong>SHELL</strong>
    <dd>
      <p>If the variable <strong>SHELL</strong> exists, the shell forked by <strong>script</strong> will be that shell. &nbsp;If <strong>SHELL</strong> is not set, the Bourne shell is assumed. &nbsp;(Most shells set this variable automatically).
  </dl>
</section>
<section>
  <h2>SEE ALSO</h2>
  <p><strong>csh</strong>(1) (for the <em>history</em> mechanism), <strong>scriptreplay</strong>(1).
</section>
<section>
  <h2>HISTORY</h2>
  <p>The <strong>script</strong> command appeared in 3.0BSD.
</section>
<section>
  <h2>BUGS</h2>
  <p><strong>script</strong> places <em>everything</em> in the log file, including linefeeds and backspaces. &nbsp;This is not what the naive user expects.
  <p><strong>script</strong> is primarily designed for interactive terminal sessions. &nbsp;When stdin is not a terminal (for example: <strong>echo foo | script</strong>), then the session can hang, because the interactive shell within the script session misses EOF and <strong>script</strong> has no clue when to close the session. &nbsp;See the <strong>NOTES</strong> section for more information.
</section>
<section>
  <h2>AVAILABILITY</h2>
  <p>The script command is part of the util-linux package and is available from <a href="ftp://ftp.kernel.org/pub/linux/utils/util-linux/">Linux Kernel Archive</a>.
</section>

