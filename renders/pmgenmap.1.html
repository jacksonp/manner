<!DOCTYPE html>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="man-page-info" data-date="PCP" data-package="Performance Co-Pilot" data-section-name="">
<title>PMGENMAP</title>
<h1>PMGENMAP</h1>
<div class="section">
  <h2>NAME</h2>
  <p><strong>pmgenmap</strong> - generate C code to simplify handling of performance metrics
</div>
<div class="section">
  <h2>SYNOPSIS</h2>
  <p><strong>pmgenmap</strong> [<em>infile</em>]
</div>
<div class="section">
  <h2>DESCRIPTION</h2>
  <p>Given one or more lists of metric names in <em>infile</em> or on standard input, <strong>pmgenmap</strong> generates C declarations and <strong>cpp</strong>(1) macros suitable for use across the Performance Metrics Programming Interface (PMAPI) on standard output.
  <p>The declarations produced by <strong>pmgenmap</strong> simplify the coding for client applications using the PMAPI.
  <p>The input should consist of one or more lists of metric names of the form
  <pre>listname {
    metricname1 symbolname1
    metricname2 symbolname2
    ...
}</pre>
  <p>which will generate C and <strong>cpp</strong>(1) declarations of the form
  <pre>char *listname[] = {
#define symbolname1 0
    "metricname1",
#define symbolname2 1
    "metricname2",
    ...
};</pre>
  <p>The array declarations produced are suitable as parameters to <strong>pmLookupName</strong>(3) and the <strong>#define</strong>d constants may be used to index the <em>vset</em>s in the <em>pmResult</em> structure returned by a <strong>pmFetch</strong>(3) call.
  <p>Obviously, <em>listname</em> must conform to the C identifier naming rules, each <em>symbolname</em> must conform to the <strong>cpp</strong>(1) macro naming rules, and each <em>metricname</em> is expected to be a valid performance metrics name (see <strong>pmns</strong>(5) for more details).
  <p>The input may include <strong>sh</strong>-style comment lines, i.e. with a `<strong>#</strong>' as the first non-blank character of a line, and these are translated on output to either single line or multi-line C comments in the K&amp;R style. For example, the input:
  <pre># leading block of multi-line comments
# initialization group
foo {
        a.b.c   ONE
        d.e.f.g TWO
        # embedded block of multi-lines
        # comments and boring pad text
        xx.yy.zz        THREE
}

# trailing single line comment</pre>
  <p>Produces the output:
  <pre>/*
 * leading block of multi-line comments
 * initialization group
 */
char *foo[] = {
#define ONE 0
        "a.b.c",
#define TWO 1
        "d.e.f.g",
/*
 * embedded block of multi-lines
 * comments and boring pad text
 */
#define THREE 2
        "xx.yy.zz",

};


/* trailing single line comment */</pre>
</div>
<div class="section">
  <h2>EXAMPLE</h2>
  <p>For brevity we have removed the error handling code, and assumed the chosen metrics do not have multiple values.
  <p>The input file
  <pre>mystats {
    kernel.percpu.cpu.idle     IDLE
    kernel.percpu.cpu.sys      SYS
    kernel.percpu.cpu.user     USER
    hinv.ncpu                       NCPU
}</pre>
  <p>produces the following C code, suitable for <strong>#include</strong>-ing
  <pre>/*
 * Performance Metrics Name Space Map
 * Built by pmgenmap from the file
 * mystats.metrics
 * on Wed Dec 28 19:44:17 EST 1994
 *
 * Do not edit this file!
 */

char *mystats[] = {
#define IDLE    0
        "kernel.percpu.cpu.idle",
#define SYS     1
        "kernel.percpu.cpu.sys",
#define USER    2
        "kernel.percpu.cpu.user",
#define NCPU    3
        "hinv.ncpu",

};</pre>
  <p>Using the code generated by <strong>pmgenmap</strong>, we are now able to easily obtain metrics from the Performance Metrics Collection Subsystem (PMCS) as follows:
  <pre>#define MAX_PMID 4

    int         trip = 0;
    int         numpmid = sizeof(mystats)/sizeof(mystats[0]);
    double      duration;
    pmResult    *resp;
    pmResult    *prev;
    pmID        pmidlist[MAX_PMID];

    pmNewContext(PM_CONTEXT_HOST, "localhost");
    pmLookupName(numpmid, mystats, pmidlist);
    pmFetch(numpmid, pmidlist, &amp;resp);

    printf("%d CPUs: %d usr   %d sys   %d   idle\n",
           resp-&gt;vset[NCPU]-&gt;vlist[0].value.lval,
           resp-&gt;vset[USER]-&gt;vlist[0].value.lval,
           resp-&gt;vset[SYS]-&gt;vlist[0].value.lval,
           resp-&gt;vset[IDLE]-&gt;vlist[0].value.lval);</pre>
  <p>Some calls to ensure portability have been removed from the code above for the sake of clarity - the example above should not be used as a template for programming. In particular, the raw values of the metrics were used when <strong>pmLookupDesc</strong>(3) should have been called to determine the semantics of each metric.
  <p>More complete examples that demonstrate the use of <strong>pmgenmap</strong> which may be used as a basis for program development are included in the PCP demos, e.g. <em>$PCP_DEMOS_DIR/pmclient</em>.
</div>
<div class="section">
  <h2>FILES</h2>
  <dl class="indent-10">
    <dt><strong>$PCP_VAR_DIR/pmns/</strong><em>*</em>
    <dd>
      <p>default PMNS specification files
  </dl>
</div>
<div class="section">
  <h2>PCP ENVIRONMENT</h2>
  <p>Environment variables with the prefix <strong>PCP_</strong> are used to parameterize the file and directory names used by PCP. On each installation, the file <em>/etc/pcp.conf</em> contains the local values for these variables. The <strong>$PCP_CONF</strong> variable may be used to specify an alternative configuration file, as described in <strong>pcp.conf</strong>(5).
</div>
<div class="section">
  <h2>SEE ALSO</h2>
  <p><strong>cpp</strong>(1), <strong>PMAPI</strong>(3), <strong>pmFetch</strong>(3), <strong>pmLookupName</strong>(3), <strong>pmNewContext</strong>(3), <strong>pcp.conf</strong>(5), <strong>pcp.env</strong>(5) and <strong>pmns</strong>(5).
</div>

